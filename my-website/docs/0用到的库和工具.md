---
id: 0
title: 0-用到的插件和工具等
---

# 📦 用到的插件和工具等
---
## pinia
- `Pinia` 是 `Vue.js` 的官方状态管理库（相当于 `Vuex` 的“继任者”）
- 【 全局的状态中心，把数据统一存放和管理，让任何组件都能方便地读取或修改 】
- `轻量`：API 简洁，没有 Vuex 冗余的 mutation 概念。
- `模块化`：每个 `store` 都是独立的（而不是像 Vuex 那样集中在一个大 store 里）。
- `支持组合式 API`：可以和 Vue3 的 `<script setup>`、`setup()` 等自然结合。
- `类型推导友好`：原生支持 `TypeScript`，智能提示比 Vuex 好很多。
- `热更新（HMR）`：开发时修改 `store` 代码，状态不丢失。
- `SSR 支持`：开箱即用，可以在 Nuxt 3 等框架中无缝使用。
1. 安装
    ```bash
      npm install pinia
    ```
2. 在 vue 项目中注册
    ```js
      //【 main.js 】
      import { createApp } from 'vue';      // 引入createApp用于创建应用
      import { createPinia } from 'pinia';  // 引入pinia
      //import router from './router';      // 引入路由器
      import App from './App.vue';          // 引入APP根组件

      const app = createApp(App);
      app.use(createPinia());               // 挂载 pinia 插件
      //app.use(router);                    // 挂载 vue-router 插件
      app.mount('#app');                    // 挂载整个应用到app容器中
    ```
3. 定义一个store
    ```js
      //【 stores/counter.js 】
      //❗️每个 store 都是一个独立文件，用 defineStore 定义。
      
      import { defineStore } from 'pinia'
      
      export const useCounterStore = defineStore('counter', {
        // ⚠️ state：相当于 data
        state: () => ({
          count: 0,
          name: 'Pinia'
        }),
      
        // ⚠️ getters：相当于 computed
        getters: {
          doubleCount: (state) => state.count * 2,
        },
      
        // ⚠️ actions：相当于 methods
        actions: {
          increment() {
            this.count++
          },
          setName(newName) {
            this.name = newName
          }
        }
      })
    ```
4. 在组件中使用
    ```js
      //❗️使用时 useXXXStore()，不需要提前注册
      <script setup>
      import { useCounterStore } from '@/stores/counter'
      
      const counter = useCounterStore()
      
      // ⚠️ 直接读写 state
      console.log(counter.count)
      counter.count++
      
      // ⚠️ 调用 action
      counter.increment()
      counter.setName('Vue3+Pinia')
      </script>
      
      <template>
        <div>
          <p>{{ counter.count }}</p>
          <p>{{ counter.doubleCount }}</p>
          <button @click="counter.increment">增加</button>
        </div>
      </template>
    ```
---
## React Router
- `React Router`：社区/第三方（由 Remix 团队维护），不是 React 核心的一部分，但事实上的主流选择（在 React 中用 react-router-dom）
- `Vue Router`：官方路由库，由 Vue 核心团队维护（Vue 3 对应 vue-router@4，Vue 2 对应 @3）
- **`React Router` 用法**
1. 安装
    ```bash
      npm i react-router-dom
    ```
2. “数据路由”写法（推荐 v6+）
- 从 `v6.4` 起，`React Router` 引入了 `Data APIs`，把“路由匹配”和“数据获取/处理”统一管理，形成了：**路由配置 = 路径 + 组件 + 数据（loader/action）**
    ```tsx
      //【 src/main.tsx 】
      import React from 'react'
      import ReactDOM from 'react-dom/client'
      import { // ⚠️
        createBrowserRouter,
        RouterProvider,
        Link,
        Outlet,
        useLoaderData,
        redirect,
      } from 'react-router-dom' 
      
      function Layout() {
        return (
          <div>
            <nav>
              <Link to="/">Home</Link>{" "}
              <Link to="/about">About</Link>{" "}
              <Link to="/users/123">User 123</Link>
            </nav>
            <Outlet />
          </div>
        )
      }
      
      function Home() { return <h1>Home</h1> }
      
      function About() { return <h1>About</h1> }
      
      function User() {
        const data = useLoaderData() as { id: string; name: string }
        return <h1>User #{data.id}: {data.name}</h1>
      }
      
      const router = createBrowserRouter([
        {
          path: '/',
          element: <Layout />,
          children: [
            { index: true, element: <Home /> },
            { path: 'about', element: <About /> },
            {
              path: 'users/:id',
              // ⚠️ 进入前获取数据/做权限判断
              loader: async ({ params }) => {
                const authed = true // 替换为你的鉴权逻辑
                if (!authed) return redirect('/')
      
                // ⚠️ 真实项目里从 API 获取
                return { id: params.id!, name: 'Alice' }
              },
              element: <User />,
            },
            { path: '*', element: <div>Not Found</div> },
          ],
        },
      ])
      
      ReactDOM.createRoot(document.getElementById('root')!).render(
        <React.StrictMode>
          <RouterProvider router={router} />
        </React.StrictMode>
      )
    ```
---
## Electron
`Electron` 是一个基于 `Chromium` 和 `Node.js` 的跨平台桌面应用开发框架，可以用前端技术（`HTML/CSS/JS`）开发桌面应用，并同时调用系统底层能力
- `Electron` 其实就是把 `浏览器内核` + `Node.js` 拼在一起，做成桌面应用运行时
- 可以在 `Electron` 里同时用`前端技术（HTML/CSS/JS）`和 `Node.js API`
- 用一个`“主进程”`调度多个`“渲染进程”`，从而既能写`前端 UI`，又能用`本地文件/进程`等系统能力
---
## Axios
`axios` 是社区广泛使用的 `HTTP` 客户端库，基于 `XHR（XMLHttpRequest）`，比 `fetch` 更好用 ｜【 `npm install axios` 】
- 支持请求超时设置
```js
  //【 内置支持 】
  axios.get("/api", { timeout: 5000 });
```
- 支持拦截器
  - `请求拦截`：可以在请求前自动加 `Authorization header`、统一处理请求参数
  - `响应拦截`：可以在返回前统一处理错误或数据格式
```js
  axios.interceptors.request.use(config => {
    config.headers.Authorization = "Bearer token";
    return config;
  });
  axios.interceptors.response.use(response => response.data, error => Promise.reject(error));
```
- 自动将响应数据转换为 `JSON` ｜ 省掉 `response.json()` 这一步
- 更好的错误处理 | 如果返回状态码是 404 或 500，会直接 `reject`，进入 `.catch` ｜ 错误对象里信息很丰富：
  - `error.response` → 包含状态码、返回头、返回体
  - `error.request` → 请求信息
  - `error.message` → 错误描述
- `axios` 在 `Node.js` 可以直接用，跨环境更友好
- `fetch` 在 `Node.js` 里需要额外安装 `node-fetch`
```js
  import axios from "axios"
  axios.get("https://xxxxxxxxx/posts")
    .then(response => {
      console.log(response.data);
    })
    .catch(error => {
      console.error("发生错误：", error);
    });
```
---
## ESLint / Prettier / Stylelint
- **`ESLint`**
  - `JavaScript`/`TypeScript` 最常用的代码规范检查工具
  - 可以配置 `Airbnb`、`Google`、`Standard` 等风格指南
  - 结合 `CI/CD`，可以强制团队提交前遵循规范
- **`Prettier`**
  - 代码格式化工具，自动调整缩进、引号、分号等格式
  - 常和 `ESLint` 配合使用（`ESLint` 管逻辑规则，`Prettier` 管代码格式）
- **`Stylelint`**
  - 针对 `CSS/SCSS` 的代码规范检查工具
  - 保证样式书写的一致性
---
## SASS & SCSS
`SCSS` 和 `SASS` 是两种流行的 `CSS` 预处理器，它们通过增强 `CSS` 的功能（如变量、嵌套、混合等）来提高样式代码的可维护性和开发效率 两者的主要区别在于语法风格
- **SASS 的特点**
- 采用缩进式语法，不使用大括号 `{}` 和分号 `;` | 它的代码风格更简洁，但对缩进要求严格，类似于 Python 的代码风格
- **SCSS 的特点**
- `SCSS` 是 `SASS` 的扩展语法，完全兼容 `CSS3`。它的语法与 `CSS` 非常相似，使用大括号 `{}` 和分号 `;` | 因此更容易被熟悉 `CSS` 的开发者接受。
- `SCSS` 与 `CSS` 完全兼容，可以直接将 `.css` 文件重命名为 `.scss` 使用，而 `SASS` 不支持直接兼容 `CSS`
---
## CesiumJS
- 一个开源的 `JavaScript` 库，用于在浏览器中展示 `3D 地球` 和 `2D 地图`
- 基于 `WebGL` 渲染，不依赖插件，跨平台运行
  - `WebGL`（`Web 图形库`）是一种 `JavaScript API`，用于在任何兼容的 `Web 浏览器`中无需插件即可渲染高性能的`交互式 3D 和 2D 图形`
- 可以在网页里直接放一个`“虚拟地球”`，并且叠加自己的数据、模型、图层
- 由美国 `AGI` 公司最早开发，有活跃的社区支持
- [一个例子 - 在北京加了一个红点](../static/0用到的库和工具/CesiumJsTest.html)
---
## Echarts
- `ECharts`（`Enterprise Charts`）是百度开源的可视化图表库，基于 `JavaScript` 和 `Canvas` 技术。
- 可以在网页里轻松生成各种交互式图表，支持 PC、移动端，无需依赖第三方插件
---
## Element Plus & Ant Design
- `Element Plus`
  - 饿了么团队开源的 UI 组件库
  - 专门为 `Vue 3` 打造
  - 前身是 `Element UI`（基于 `Vue 2`）
  - 在国内 `Vue` 项目里使用率非常高
- `Ant Design` (`antd`)
  - 阿里巴巴蚂蚁金服团队开源
  - 最初是基于 `React` 的组件库
  - 设计规范很完整，重视“企业级中后台系统”
  - 也有社区维护的 Vue 版本（`ant-design-vue`），但官方重点还是 `React`
---
## Umi
`Umi` 是一个基于 `React` 的前端应用框架，主要用于构建中大型前端项目
- 由 `Ant Design` 团队/蚂蚁金服社区开发
- 提供【约定式路由】、【插件化】、【构建优化】、【TypeScript支持】等能力
- 本质上类似于一个增强版的 `React` + `路由` + `脚手架`，强调开发效率和可维护性
```bash
  # 安装 Umi
  npm install -g umi

  # 创建项目
  mkdir my-app && cd my-app
  umi init
```
---
## Umami
- `Umami` 是一个开源的轻量级网站访问分析工具（类似 `Google Analytics`，但开源、自托管）
- 主要用于网站流量统计，关注隐私，不依赖第三方服务器
- 【埋点原理】
- 通过在网页中插入一段小的 `JavaScript` 脚本（通常是 `umami.js`），监听页面的访问和交互事件
- 将数据发送到 `Umami` 后端 API，后端记录到数据库（`PostgreSQL` 或 `MySQL`）
- 前端通过仪表盘展示统计结果。它可以统计`页面浏览（PV）`、`独立访客（UV）`、`事件（点击、表单提交等）`、`来源`、`设备信息`等
---
## Docusaurus
- `Docusaurus` 是 `Meta（Facebook）` 开源的文档型静态网站生成器
- 它的定位和特点：
  - 专注文档：特别适合把一堆 `Markdown` 文件转成一个结构化的网站
  - 基于`React`：底层是 `React`，可以自定义组件
  - 支持版本化文档：适合 API、规范等有版本管理的项目
  - 内置搜索、多语言、博客系统
  - 部署简单：生成的是静态网页，可以放在 GitHub Pages、Vercel、Netlify 等
- 【 把这个知识点小记录全部打包成一个静态网站： 】
  - 在项目根目录执行：
  ```bash
    npx create-docusaurus@latest my-website classic
  ```
  - 会生成一个 `my-website/` 文件夹，里面就是 `Docusaurus` 的结构 | 进入目录：
  ```bash
    cd my-website
    npm install
    npm run start
  ```
  - 就能在本地看到一个示例文档站点
  - 把本地的 `Markdown` 文件全部复制到 `my-website/docs/` 目录下
  - 把本地的静态文件全部复制到 `my-website/static/` 目录下
  - 配置 `sidebars.js`
  ```js
    module.exports = {
      tutorialSidebar: [
        '0用到的库和工具',  // 对应 docs/0用到的库和工具.md 的 id
        '1计算机网络相关',  // 对应 docs/1计算机网络相关.md 的 id
      ],
    };
  ```
  ```bash
    # 开发预览：
    npm run start
    # 静态构建（生成纯 HTML+JS+CSS 文件）：
    npm run build
  ```
---
## IndexedDB
`IndexedDB` 是一种底层 `API`；用于在`客户端`存储大量的结构化数据（也包括文件/二进制大型对象（blobs））；该 `API` 使用索引实现对数据的高性能搜索； 虽然 `Web Storage` 在存储较少量的数据很有用 但对于存储更大量的结构化数据来说力不从心； 而 `IndexedDB` 提供了这种场景的解决方案
- 一个基于 `JavaScript` 的面向对象数据库
- 允许存储和检索`用键索引的对象`；可以存储结构化克隆算法支持的任何对象
- 只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务
---
## three.js
`three.js` | 基于浏览器的 3D 渲染与图形框架，JS/TS编写，对底层的WebGL及正在推进中的WebGPU做了**高层封装**，可以用很少的代码在网页中绘制、加载与交互三维内容。（3D数据可视化、产品展示、地图与城市孪生、粒子/体渲染、科学计算结果演示、游戏原型等等）
- **Scene**｜场景｜一切3D对象的容器
- **Camera**｜相机｜常用：`PerspectiveCamera（透视相机）` `OrthographicCamera（正交相机）`
- **Renderer**｜渲染器｜把3D场景绘制到`<canvas>`（`WebGLRenderer` `实验性的WebGPURenderer`）
- **Mesh**｜网格｜`Geometry`+`Material`：可见的3D物体
  - `Geometry`：顶点数据容器，现代three.js使用`BufferGeometry`（属性如`position/normal/uv/index`）
  - `Material`：表观/着色方式
- **Lights**｜光源｜
- **Controls**｜交互｜如`OrbitControls`，旋转/缩放/平移镜头