---
id: 9
title: 9-前端工程化
---

# 🧰 前端工程化
---
## 前端工程化（框架）

将前端开发过程中一系列`流程`和`工具`进行`规范化`，并使用相关技术实现`自动化` | 提高`开发效率` 提高`代码质量`和`可维护性`

1. `项目初始化` 快速建立可维护项目的基础结构
    - 包管理工具：`npm` `yarn` `pnpm`
    - 脚手架工具：`create-react-app` `vue-cli`
2. `模块化/组件化开发` 结构清晰、可复用、易维护
    - 模块化规范：`CommonJS`(Node.js中使用) `ES Module`
    - 组件化框架：`React` `Vue` `Svelte` `Solid.js`
3. `构建与打包` 将代码编译、优化成可在生产环境运行的资源
    - 构建工具：`Webpack` `Vite` `Rollup` `Esbuild`
4. `代码规范与质量` 保证团队协作代码风格统一、减少潜在错误
    - 代码规范检查：`ESLint` `Prettier` `Stylelint`
    - 类型检查：`TypeScript` `Flow`
    - 代码提交规范：`Git Hooks` `Commit message`
---
## Node.js 在前端工程化中的作用
`1 运行环境` `2 工具支撑` `3 开发体验提升`
1. 工具链的运行环境
    - 以前浏览器之外，`JavaScript` 是没法直接运行的，`Node.js` 让我们可以在`本地直接执行 JavaScript`，这意味着：
    - 前端构建工具（Webpack/Vite/Rollup）都能在本地跑
    - 脚手架（如 `create-react-app`、`vue-cli`）能直接生成项目
2. 模块化与包管理 工具链的依赖环境
    - 包管理器（npm / yarn / pnpm）依赖 Node.js、
    - 构建工具（Webpack、Rollup、Vite）运行在 Node.js 环境
    - Lint / 格式化工具（ESLint、Prettier）也是 Node.js 脚本
    - 允许前端代码通过`require`或`import`引入第三方库
3. 本地开发服务器与代理
    - Node.js 自带`网络模块（http）`，可以很方便地启动本地开发服务：
    - 热更新（HMR）依赖 Node.js 服务器来推送变更
    - API Mock（接口模拟）可直接用 Node.js 写本地接口
    - 前后端同构渲染（SSR）直接用 Node.js 处理 HTML 模板
    - 解决跨域问题时，常用`Node.js`中间件（如 `http-proxy-middleware`）做请求转发。
4. 自动化脚本与工具开发
    - 批量构建多个项目
    - CI/CD 脚本（部署、构建、运行测试）
    - 文件监听（用 `chokidar` 等库）
    - 脚本工具化（用 `commander` 写 CLI 工具）
    - 开发自定义 CLI 工具（如生成模板代码、批量处理文件）
5. 跨平台开发支持
    - Node.js 的跨平台能力（Windows / macOS / Linux 都能跑）
---
## Webpack 和 Vite
`Webpack` 和 `Vite` 是两种广泛使用的构建工具
- 【 入口文件 】
  - **`Webpack`** 默认入口是 `src/index.js`，但可通过 `entry` 配置修改
  - **`Vite`** 没有强制的入口，直接基于 `index.html`，通过 `<script type="module">` 作为入口（更贴近浏览器原生运行）
- 【 开发模式的差异 】
  - **`Webpack`** 开发环境中先打包再启动开发服务器 【 1.遍历依赖 | 2.全量打包 | 3.启动服务器 】增加启动时间和构建时间
  - **`Vite`** 直接启动 再按需编译依赖文件【 1.启动服务器 | 2.按需加载 | 3.动态加载 】（ 打开浏览器F12 检查源码 `Sources` ）
  - 现代浏览器本身就支持 `ES Modules` 会主动发起请求去获取所需文件 `Vite` 充分利用了这一点 将开发环境下的模块文件直接作为浏览器要执行的文件 而不是像 `Webpack` 那样先打包 再交给浏览器执行
- 【 底层语言 】
  - `Webpack` 基于 `Node.js` 构建
  - `Vite` 基于 `esbuild` 进行预构建
- 【 热更新的处理 】
  - `Webpack` ｜ 当一个模块或其依赖的模块内容改变时 需要重新编译这些模块
  - `Vite` ｜ 当某个模块内容改变时 只需要让浏览器重新请求这个模块即可 大大减少热更新时间
---
## ESM (ECMAScript Modules)
`JavaScript` 在 `ES6（2015）`中引入的官方模块化标准 | 在 ES6 之前，JavaScript 并没有统一的模块系统：
- `浏览器`：只能用 `<script>` 标签引入，所有 `JS` 都是全局变量，很容易冲突
- `Node.js`：早期用 `CommonJS (CJS)`（`require` / `module.exports`），但这不是浏览器原生支持的
- 【特征】
  - 静态导入导出 ｜ 使用 `import` / `export`，在代码运行前就能确定依赖关系
  - 有利于编译器优化（比如 `Tree Shaking`）
  - 按需导入导出 | 只引入用到的部分，避免把整个文件都加载
  - 严格模式 | ESM 默认就是严格模式（`'use strict'` 不需要写）
  - 异步加载 | 浏览器原生支持 `<script type="module">`，加载时不会阻塞 `HTML` 解析
  - 浏览器原生支持 | 现代浏览器直接支持，不需要打包工具
- `ES Modules` VS `CommonJS`

| 特性 | ESM | CommonJS (CJS) |
| --- | --- | --- |
| 语法 | `import` / `export` | `require` / `module.exports` |
| 加载 | 静态编译时确定依赖 | 运行时动态加载 |
| 是否异步 | 异步（更适合浏览器） | 同步（更适合 Node.js）|
| 优化 | 支持 Tree Shaking | 不支持 |
| 应用 | 浏览器 + Node.js | 主要在 Node.js（旧项目多）|

- `Tree Shaking` | 就是打包时移除没有用到的代码
- `ES Modules`是异步的｜加载特点：**(1)** 浏览器遇到 `<script type="module">` 会异步下载和解析依赖，不会阻塞 `HTML` 渲染。**(2)** `import` 本身是静态声明，但浏览器执行时会异步请求依赖文件（走网络）
- `CommonJS 特点`是同步的｜加载特点：**(1)** 用 `require` 引入模块：执行到这一行时，必须立刻去磁盘（或缓存）加载并执行 math.js，然后才往下走。所以 `require` 是阻塞式的同步操作。**(2)** CommonJS 设计场景是 Node.js 服务器，本地磁盘 IO 很快，不需要异步。**(3)** 如果放在浏览器里，require 就很慢（要阻塞等待整个模块加载），所以 CJS 不适合浏览器端直接使用。
---
## WASM（WebAssembly）
- `WASM`（`WebAssembly`）是一种**高效的、低级别的二进制格式**，用于在浏览器中运行代码。
- 是一种与平台无关的技术，设计目标是让开发者能够**将高性能代码运行在浏览器中**，同时具有接近原生的性能表现。
- `WebAssembly` 可以被看作是浏览器的`“虚拟机语言”`，它允许开发者将用其他编程语言（如 `C`、`C++`、`Rust` 等）编写的代码编译成**二进制格式**，然后在浏览器中运行。
- 这种方式突破了传统 `JavaScript` 的性能瓶颈，特别适合需要高性能计算的场景，比如**游戏、图像处理、视频编辑、科学计算等**。
- 1️⃣ **【 `WASM` 的核心特点 】**
  - **高性能：**| `WebAssembly` 是一种**二进制格式**，运行时直接被浏览器的 `WebAssembly` 虚拟机加载和执行，省去了 `JavaScript` 的解析和编译步骤。 | 接近原生性能（Native Performance），适用于需要大量计算的场景。
  - **跨平台：**| `WebAssembly` 是**与平台无关**的，可以在任何支持 `WebAssembly` 的环境中运行，包括`主流浏览器`（`Chrome`、`Firefox`、`Safari`、`Edge`）和 `Node.js`。
  - **语言无关：**| `WebAssembly` 是一种**编译目标**，可以通过编译器（如 `LLVM`）将多种编程语言（如 `C`、`C++`、`Rust`、`Go` 等）编译成 `WebAssembly`。
  - **安全性：**| `WebAssembly` 运行在**沙盒环境**中，遵循浏览器的安全模型，无法直接访问底层操作系统资源，安全性高。
  - **模块化：**| `WebAssembly` 支持**模块化设计**，可以与 `JavaScript` 进行高效交互，适合构建复杂的应用程序。
- 2️⃣ **【 `WASM` 的文件结构 】**
  - `WebAssembly` 的核心是 `.wasm` 文件，它是一种**紧凑的二进制格式**，包含以下内容：
  - **模块：**| `WebAssembly` 的代码组织单位是**模块**，**一个模块**可以包含**多个函数、内存定义、全局变量等**。
  - **导入和导出：**| `WebAssembly` 模块可以导入外部资源（如 JavaScript 函数），也可以导出自己的函数供 JavaScript 使用。
  - **指令集：**| `WebAssembly` 使用简单的、低级指令集，适合直接翻译成机器代码。
- 3️⃣ **【 WebAssembly 与 JavaScript 的关系 】**
  - `WebAssembly` 并不是 JavaScript 的替代品，而是两者的互补，它专注于高性能计算
  - `JavaScript` 仍然是构建用户界面的首选语言。

  |特性|WebAssembly|JavaScript|
  |---|---|---|
  |性能|	    接近原生性能|	              较慢（解释型语言）|
  |编程语言|	支持多种语言（如 C、Rust）|	    只能使用 JavaScript|
  |可读性|	    二进制文件，不易阅读|	        可读性高（文本格式）|
  |应用场景|	**高性能计算、游戏、科学计算**|	  **用户界面、业务逻辑**|